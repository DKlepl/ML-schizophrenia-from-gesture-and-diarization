---
title: "Feature Engineering"
author: "Dominik Klepl"
date: "10/15/2018"
output: html_document
---

After the preprocessing phase the data is clean, actigraph data is tagged by speaker. Before the features can be extracted data from every participant will be split into small snippets and in 2 categories: single signal and synergy.
In single signal the snippet is 1 utterance long.
In synergy the snippet is 1 utterance-exchange long (1st speaker followed by 2nd speaker).

First I write code and functions to split the data correctly on one sample file.

Load sample - both diarization and actigraph data
```{r}
all_gest = list.files("clean_data/Gesture")

gest = read.csv("clean_data/Gesture/142_0_tagged.csv")
```

## 1. Single signal splitting

First we clean the actigraph data - remove silence
```{r}
all_gest = list.files("clean_data/Gesture", full.names = T)
actigraph = all_gest[54]

load_actigraph = function(file) {
  data = read.csv(file)
  data = data[,-1]
  
  #remove silence
  data = subset(data, interviewer !=-1)
  
  return(data)
}

d = load_actigraph(actigraph)
```

Now it must be decided which utterances should be used, what's the minimal lenght
```{r}

#look at one utterance
t = subset(gest, utterance_n==88)

plot(t$ParticipantJerkRight, type='l')
plot(t$PsychologistJerkRight, type='l')

#inspect some desc statitistics and plots
library(pastecs)
round(stat.desc(diar$Duration),2)

hist(diar$Duration)
sum(diar$Duration>0.5)
```

Get info out of the name of the file.
```{r}
get_info = function(file) {
  filename = strsplit(file, "/")[[1]][3]
  split = strsplit(filename, "_")[[1]]
  info = data.frame(ID = split[1],
                    right = split[2])
  
  return(info)
}
```

Split the file into utterance-long mini files and save them in a separate folders. Also the utterances need to be categorized in 2 folders, by interlocutor.

```{r}
inf=get_info(actigraph)

split_save_single = function (data, info) {
  for (n in unique(data$utterance_n)) {
    actigraph_subset = subset(data, utterance_n==n)
    
    #construct name of the file to save
    name = paste(info$ID, n, info$right, sep="_")
    
    save_path = "trash/"
    try(if (actigraph_subset$interviewer[1]==0) {
      save_path = "clean_data/Split_data/Single/Participant/"
    } else save_path = "clean_data/Split_data/Single/Interviewer/")
    
    save_as = paste0(save_path, name, ".csv")
    
    write.csv(actigraph_subset, save_as, row.names = F)
  }
}

split_save_single(data=d,info=inf)
```

# Coordination splitting
Split the interview into pairs of utterances of the 2 interlocutors. Order doesn't matter, important is that the pair includes one utterance from each interlocutor.

Load sample diarization and gesture
```{r}
all_gest = list.files("clean_data/Gesture", full.names = T)
all_diar =list.files("clean_data/Diarization", full.names = T)

gest = all_gest[1]
diar = all_diar[1]

#extract info out of the filename
info = get_info(diar)

gest = load_actigraph(gest)
diar = read.csv(diar)
```

Form the pairs of utterances using diarization entries first. Then the start and end times can be used to get the data out of actigraph data. This code is then wrapped into function in the script.
```{r}
#number the utterances (should correspond to utterance_n in actigraph)
diar$utterance_n = seq(1, nrow(diar))

#split by interlocutor
diar_i = subset(diar, Interlocutor=="Interviewer")
diar_p = subset(diar, Interlocutor == "Participant")

#sanity check that I didn't loose any data
nrow(diar_i) + nrow(diar_p) == nrow(diar)

#dataframe to store the pairs in
pairs = data.frame(ID = numeric(),
                   utterance_1 = numeric(),
                   utterance_2 = numeric(),
                   latency = numeric())

#search for closest utterance in time - pick one utterance in diar_i and compare it to all in diar_p
for (n in 1:nrow(diar_i)) {
  one_utterance = diar_i[n,]
  
  #sometimes there might be 2 utterances to pair with, before and after the given utterance
  end_start_diff = abs(diar_p$StartTime-one_utterance$EndTime)
  following_utterance = diar_p[which.min(end_start_diff),]
  
  #append the pair to the pairs dataframe
  f_pair = data.frame(ID=info$ID,
                      utterance_1 = one_utterance$utterance_n,
                      utterance_2 = following_utterance$utterance_n,
                      latency = end_start_diff[which.min(end_start_diff)])
  pairs = rbind(pairs, f_pair)
  
  start_end_diff = abs(one_utterance$StartTime-diar_p$EndTime)
  previous_utterance = diar_p[which.min(start_end_diff),]
  
  #append the pair to the dataframe
  p_pair = data.frame(ID=info$ID,
                      utterance_1 = one_utterance$utterance_n,
                      utterance_2 = previous_utterance$utterance_n,
                      latency = start_end_diff[which.min(start_end_diff)])
  pairs = rbind(pairs, p_pair)
}
```

## Split actigraphs into coordination pairs
Get unique coordination pairs and split the actigraph data using the pairs.
```{r}
coordination_pairs = read.csv("clean_data/Split_data/coordination_pairs.csv")

#turn all variables to numeric
coordination_pairs$latency = as.numeric(as.character(coordination_pairs$latency))

coordination_pairs = na.omit(coordination_pairs)

#inspect the latency
range(coordination_pairs$latency)
hist(coordination_pairs$latency)
cutoff = mean(coordination_pairs$latency)+(3*(sd(coordination_pairs$latency)))
coordination_pairs = subset(coordination_pairs, latency<cutoff)
mean(coordination_pairs$latency)

coordination_pairs = tidyr::unite(coordination_pairs, pair, c(ID,utterance_1, utterance_2), remove=F)

#keep only unique pairs
unique_pairs = as.data.frame(unique(coordination_pairs$pair))

#unwrap the pairs again
coordination_pairs = separate(data=unique_pairs, col="unique(coordination_pairs$pair)",into=c('ID', 'u_1', 'u_2'), sep="_")

#save the final pairs
write.csv(coordination_pairs, "clean_data/Split_data/coordination_pairs.csv", row.names = F)
```

The cbind.na function for merging vectors of unequal lenght.
```{r}
cbind.na <- function (..., deparse.level = 1) 
{
    na <- nargs() - (!missing(deparse.level))    
    deparse.level <- as.integer(deparse.level)
    stopifnot(0 <= deparse.level, deparse.level <= 2)
    argl <- list(...)   
    while (na > 0 && is.null(argl[[na]])) {
        argl <- argl[-na]
        na <- na - 1
    }
    if (na == 0) 
        return(NULL)
    if (na == 1) {         
        if (isS4(..1)) 
            return(cbind2(..1))
        else return(matrix(...))  ##.Internal(cbind(deparse.level, ...)))
    }
    if (deparse.level) {       
        symarg <- as.list(sys.call()[-1L])[1L:na]
        Nms <- function(i) {
            if (is.null(r <- names(symarg[i])) || r == "") {
                if (is.symbol(r <- symarg[[i]]) || deparse.level == 
                  2) 
                  deparse(r)
            }
            else r
        }
    }   
    ## deactivated, otherwise no fill in with two arguments
    if (na == 0) {
        r <- argl[[2]]
        fix.na <- FALSE
    }
    else {
        nrs <- unname(lapply(argl, nrow))
        iV <- sapply(nrs, is.null)
        fix.na <- identical(nrs[(na - 1):na], list(NULL, NULL))
        ## deactivated, otherwise data will be recycled
        #if (fix.na) {
        #    nr <- max(if (all(iV)) sapply(argl, length) else unlist(nrs[!iV]))
        #    argl[[na]] <- cbind(rep(argl[[na]], length.out = nr), 
        #        deparse.level = 0)
        #}       
        if (deparse.level) {
            if (fix.na) 
                fix.na <- !is.null(Nna <- Nms(na))
            if (!is.null(nmi <- names(argl))) 
                iV <- iV & (nmi == "")
            ii <- if (fix.na) 
                2:(na - 1)
            else 2:na
            if (any(iV[ii])) {
                for (i in ii[iV[ii]]) if (!is.null(nmi <- Nms(i))) 
                  names(argl)[i] <- nmi
            }
        }
           
        ## filling with NA's to maximum occuring nrows
        nRow <- as.numeric(sapply(argl, function(x) NROW(x)))
        maxRow <- max(nRow, na.rm = TRUE)  
        argl <- lapply(argl, function(x)  if (is.null(nrow(x))) c(x, rep(NA, maxRow - length(x)))
                                          else rbind.na(x, matrix(, maxRow - nrow(x), ncol(x))))
        r <- do.call(cbind, c(argl[-1L], list(deparse.level = deparse.level)))
    }
    d2 <- dim(r)
    r <- cbind2(argl[[1]], r)
    if (deparse.level == 0) 
        return(r)
    ism1 <- !is.null(d1 <- dim(..1)) && length(d1) == 2L
    ism2 <- !is.null(d2) && length(d2) == 2L && !fix.na
    if (ism1 && ism2) 
        return(r)
    Ncol <- function(x) {
        d <- dim(x)
        if (length(d) == 2L) 
            d[2L]
        else as.integer(length(x) > 0L)
    }
    nn1 <- !is.null(N1 <- if ((l1 <- Ncol(..1)) && !ism1) Nms(1))
    nn2 <- !is.null(N2 <- if (na == 2 && Ncol(..2) && !ism2) Nms(2))
    if (nn1 || nn2 || fix.na) {
        if (is.null(colnames(r))) 
            colnames(r) <- rep.int("", ncol(r))
        setN <- function(i, nams) colnames(r)[i] <<- if (is.null(nams)) 
            ""
        else nams
        if (nn1) 
            setN(1, N1)
        if (nn2) 
            setN(1 + l1, N2)
        if (fix.na) 
            setN(ncol(r), Nna)
    }
    r
}
```

